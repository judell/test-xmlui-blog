<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>XMLUI blog test</title>
  <script src="xmlui/0.10.8-xmlui-blog.js"></script>
  <script src="xmlui/xmlui-playground.js"></script>
  <script src="xmlui/xmlui-search.js"></script>
<script>

  window.blogIsIndexing = '';

  window.setBlogIndexing = function() {
    window.blogIsIndexing = 'indexing'
  }

  window.stopBlogIndexing = function() {
    window.blogIsIndexing = 'done'
  }

  // Initialize blog search data
  window.blogPosts = {};

  window.searchResults = {};

  // Getter function
  window.getBlogPosts = function() {
    return window.blogPosts;
  };

      // Markdown to plain text conversion function
  function markdownToPlainText(markdown) {
    let cleanedText = markdown;

    // Remove HTML/XML tags first
    cleanedText = cleanedText.replace(/<[^>]*>/g, '');

    // Remove headers
    cleanedText = cleanedText.replace(/#{1,6}\s+/g, '');

    // Remove bold/italic
    cleanedText = cleanedText.replace(/\*\*(.*?)\*\*/g, '$1');
    cleanedText = cleanedText.replace(/\*(.*?)\*/g, '$1');

    // Remove inline code
    cleanedText = cleanedText.replace(/`(.*?)`/g, '$1');

    // Remove code blocks
    cleanedText = cleanedText.replace(/```[\s\S]*?```/g, '');

    // Remove links, keep text
    cleanedText = cleanedText.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');

    // Remove images, keep alt text
    cleanedText = cleanedText.replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1');

    // Remove admonition tags
    cleanedText = cleanedText.replace(/\\?\[!\w+\]\s*/g, "");

    // Remove anchor tags
    cleanedText = cleanedText.replace(/\s*\\\[#.*?\]/g, "");

    // Process tables
    const lines = cleanedText.split("\n");
    const reformattedLines = lines.map((line) => {
      const trimmedLine = line.trim();

      // Remove table separators
      if (trimmedLine.match(/^\|(?:\s*---\s*\|)+$/)) {
        return null;
      }

      // Reformat table rows
      if (trimmedLine.startsWith("|") && trimmedLine.endsWith("|")) {
        return trimmedLine
          .slice(1, -1)
          .split("|")
          .map((cell) => cell.trim())
          .join(" - ");
      }

      // Remove code block markers
      if (trimmedLine.startsWith("```") || trimmedLine.startsWith("---")) {
        return null;
      }

      return line;
    });

    cleanedText = reformattedLines.filter((line) => line !== null).join("\n");

    // Normalize line breaks
    cleanedText = cleanedText.replace(/(\r\n|\n){3,}/g, "\n\n");

    return cleanedText.trim();
  }

  // Setter function
  window.setBlogSearchEntry = function(key, content) {
    // Strip markdown to create clean plain text for search
    const plainText = markdownToPlainText(content);
    window.blogPosts[key] = plainText;
  };

  // Get count function
  window.getBlogSearchCount = function() {
    return Object.keys(window.blogPosts).length;
  };

  window.getBlogSearchResults = function() {
    return window.searchResults();
  }

  window.setBlogSearchResults = function(results) {
    window.searchResults = results;
  };


        // Search function that returns filtered results grouped by post
  window.searchBlogPosts = function(posts, searchIndex, query) {
    console.log('Search query:', query);
    console.log('Search index keys:', Object.keys(searchIndex));

    if (!query || query.trim().length === 0 || !posts || !searchIndex) return [];

    const postResults = {}; // Group results by post

    Object.keys(posts).forEach(function(key) {
      const post = posts[key];
      const queryLower = query.toLowerCase();
      const postMatches = [];

      // Search in title
      if (post.title.toLowerCase().includes(queryLower)) {
        postMatches.push({
          matchType: 'title',
          context: post.title
        });
      }

      // Search in content - find all occurrences
      const content = searchIndex['/blog/' + post.slug];
      if (content && content.toLowerCase().includes(queryLower)) {
        let searchPos = 0;
        const seenContexts = new Set(); // Track seen contexts to avoid duplicates

        while (true) {
          const index = content.toLowerCase().indexOf(queryLower, searchPos);
          if (index === -1) break; // No more matches

          const start = Math.max(0, index - 100);
          const end = Math.min(content.length, index + 100);
          let context = content.substring(start, end);

          if (start > 0) context = '...' + context;
          if (end < content.length) context = context + '...';

          // Only add if we haven't seen this context before
          if (!seenContexts.has(context)) {
            postMatches.push({
              matchType: 'content',
              context: context
            });
            seenContexts.add(context);
          }

          searchPos = index + 1; // Move past this match to find next one
        }
      }

      // Only add posts that have matches
      if (postMatches.length > 0) {
        postResults[key] = {
          key: key,
          post: post,
          matches: postMatches
        };
      }
    });

    window.setBlogSearchResults(postResults);

    return Object.values(postResults);
  };
</script>
</head>
<body>
</body>
</html>
